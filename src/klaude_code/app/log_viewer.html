<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Klaude Log Viewer</title>
<link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%23e3dac7'/%3E%3Cpath d='M22 18h8v12l10-12h10L36 34l14 12H40L30 36v10h-8V18z' fill='%23141413'/%3E%3C/svg%3E">
<link rel="preconnect" href="https://cdnjs.cloudflare.com">
<link href="https://cdnjs.cloudflare.com/ajax/libs/Iosevka/6.0.0/iosevka/iosevka.min.css" rel="stylesheet">
<style>
:root {
  --bg: #fcfbf9;
  --bg-surface: #ffffff;
  --bg-hover: #f3f1eb;
  --bg-selected: #f0ede5;
  --bg-deep: #e3dac7;
  --border: #e8e6df;
  --border-strong: #d4d1c9;
  --fg: #141413;
  --fg-secondary: #5e5c56;
  --fg-tertiary: #a19f95;
  --accent: #d97757;
  --accent-strong: #c6613f;
  --radius: 8px;
  --radius-sm: 4px;
  --font-sans: 'Iosevka Web', 'Iosevka', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  --font-serif: 'Iosevka Web', 'Iosevka', Georgia, serif;
  --font-mono: 'Iosevka Web', 'Iosevka', 'SF Mono', 'Fira Code', monospace;
  --code-key: #2f2b22;
  --code-str: #1b6b5c;
  --code-num: #b26b1d;
  --code-bool: #2e5c8a;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: var(--font-sans);
  font-size: 16px;
  background: var(--bg);
  color: var(--fg);
  height: 100vh;
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#container { display: flex; height: 100vh; }

/* Left panel */
#left {
  flex: 1;
  min-width: 0;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: var(--bg);
}

/* Toolbar */

#toolbar, #right-toolbar {
  height: 52px;
  box-sizing: border-box;
  padding: 0 16px;
}

#toolbar {
  display: flex;
  align-items: center;
  gap: 12px;
  
  background: var(--bg);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;

}
#toolbar .title {
  color: var(--fg);
  font-family: var(--font-serif);
  font-size: 16px;
  font-weight: 700;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex: 1;
  letter-spacing: -0.01em;
}
.nav-btn {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--fg-secondary);
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 16px;
  font-weight: 700;
  font-family: var(--font-sans);
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
  box-shadow: 0 1px 2px rgba(0,0,0,0.02);
}
.nav-btn:hover {
  background: var(--bg-hover);
  color: var(--fg);
  border-color: var(--border-strong);
}
#toolbar .filter-group {
  display: flex;
  gap: 6px;
  flex-shrink: 0;
  flex-wrap: wrap;
}
.filter-btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: var(--bg-surface);
  border: 1px solid var(--border-strong);
  color: var(--fg-secondary);
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 16px;
  font-weight: 700;
  font-family: var(--font-sans);
  cursor: pointer;
  transition: all 0.2s ease;
  line-height: 1.2;
}
.filter-btn:hover {
  background: var(--bg-hover);
  color: var(--fg);
  border-color: var(--fg-tertiary);
}
.filter-btn.active { 
  background: #dbeafe; 
  color: #1e3a8a; 
  border-color: #bfdbfe;
  box-shadow: none; 
}
.filter-btn.active::after {
  content: '\00d7';
  font-size: 14px;
  line-height: 1;
  opacity: 0.85;
}

#search-box {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--fg);
  padding: 6px 12px;
  border-radius: 6px;
  font-size: 16px;
  font-family: var(--font-sans);
  width: 200px;
  outline: none;
  transition: all 0.2s ease;
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.02);
}
#search-box:focus {
  border-color: var(--fg-tertiary);
  box-shadow: 0 0 0 2px rgba(20,20,19,0.05);
}
#search-box::placeholder { color: var(--fg-tertiary); }

/* Log list */
#log-list {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  font-family: var(--font-mono);
  font-size: 16px;
  background: var(--bg);
  padding: 8px 0;
}
.log-line {
  padding: 2px 16px;
  cursor: pointer;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  line-height: 20px;
  border-radius: 4px;
  margin: 1px 8px;
  transition: background 0.1s ease;
}
.log-line:hover { background: var(--bg-hover); }
.log-line.selected {
  background: var(--bg-selected);
  border-radius: 6px;
}
.log-line .ts { color: var(--fg-tertiary); }
.log-line .dtype-wrapper { display: inline-block; min-width: 90px; text-align: left; }
.log-line .dtype { display: inline-block; font-family: var(--font-sans); font-weight: 700; font-size: 16px; letter-spacing: 0.03em; padding: 2px 6px; border-radius: 4px; line-height: 1.2; }
.log-line .dtype-GENERAL { color: #5e5c56; background: #e8e6df; }
.log-line .dtype-LLM_CONFIG { color: #9a6700; background: #fdf3d1; }
.log-line .dtype-LLM_PAYLOAD { color: #0b5e20; background: #e6f6e6; }
.log-line .dtype-LLM_STREAM { color: #005fcc; background: #e6f0fa; }
.log-line .dtype-UI_EVENT { color: #7c2d12; background: #ffedd5; }
.log-line .dtype-RESPONSE { color: #5b21b6; background: #ede9fe; }
.log-line .dtype-EXECUTION { color: #0f766e; background: #ccfbf1; }
.log-line .dtype-TERMINAL { color: #be123c; background: #ffe4e6; }
.log-line .msg { color: var(--fg-secondary); }
.log-line .json-inline { color: var(--fg-tertiary); }
.log-line .lineno {
  color: var(--fg-tertiary);
  display: inline-block;
  width: 3em;
  text-align: right;
  margin-right: 12px;
  user-select: none;
  font-size: 16px;
}
.log-line .badge {
  display: inline-block;
  padding: 1px 6px;
  margin: 0 3px;
  border-radius: var(--radius-sm);
  font-size: 16px;
  font-family: var(--font-sans);
  font-weight: 700;
  line-height: 18px;
  vertical-align: middle;
  background: var(--bg-surface);
  color: var(--fg-secondary);
  border: 1px solid var(--border);
  box-shadow: 0 1px 1px rgba(0,0,0,0.02);
}
.log-line.hidden { display: none; }

/* Right panel */
#right {
  width: 50%;
  min-width: 300px;
  display: flex;
  flex-direction: column;
  background: var(--bg-surface);
  border-left: 1px solid var(--border);
}
#right-toolbar {
  display: flex;
  align-items: center;
  gap: 8px;
  
  background: var(--bg-surface);
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;

}
#right-toolbar .label {
  color: var(--fg);
  font-family: var(--font-sans);
  font-size: 16px;
  font-weight: 700;
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.action-btn {
  background: var(--bg-surface);
  border: 1px solid var(--border);
  color: var(--fg-secondary);
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 16px;
  font-weight: 700;
  font-family: var(--font-sans);
  cursor: pointer;
  transition: all 0.2s ease;
  white-space: nowrap;
  box-shadow: 0 1px 2px rgba(0,0,0,0.02);
}
.action-btn:hover { background: var(--bg-hover); color: var(--fg); border-color: var(--border-strong); box-shadow: 0 1px 2px rgba(0,0,0,0.05); }
#btn-copy {
  background: var(--fg);
  color: var(--bg-surface);
  border-color: var(--fg);
}
#btn-copy:hover {
  background: var(--fg-secondary);
  border-color: var(--fg-secondary);
}

/* JSON viewer */
#json-view {
  flex: 1;
  overflow: auto;
  padding: 12px 8px;
  font-family: var(--font-mono);
  font-size: 16px;
  line-height: 1.4;
  background: var(--bg-surface);
}
#json-view .empty-hint {
  color: var(--fg-tertiary);
  font-family: var(--font-sans);
  font-size: 16px;
  display: block;
  padding: 20px 16px;
  text-align: center;
  margin-top: 40px;
}

/* JSON tree */
.jt-row {
  display: flex;
  align-items: flex-start;
  line-height: 22px;
  padding: 0 12px 0 0;
  border-radius: 4px;
}
.jt-row:hover { background: var(--bg-hover); }
.jt-lineno {
  color: var(--fg-tertiary);
  min-width: 3em;
  text-align: right;
  padding-right: 12px;
  flex-shrink: 0;
  user-select: none;
  font-size: 16px;
}
.jt-indent { display: inline-block; flex-shrink: 0; }
.jt-arrow {
  width: 18px;
  flex-shrink: 0;
  cursor: pointer;
  user-select: none;
  color: var(--fg-tertiary);
  font-size: 8px;
  text-align: center;
  line-height: 22px;
  transition: color 0.1s;
}
.jt-arrow:hover { color: var(--fg); }
.jt-arrow-ph { width: 18px; flex-shrink: 0; }
.jt-key { color: var(--code-key); }
.jt-colon { color: var(--fg-tertiary); margin-right: 6px; }
.jt-str { color: var(--code-str); word-break: break-all; white-space: pre-wrap; }
.jt-str.clamped { display: -webkit-box; -webkit-line-clamp: 10; -webkit-box-orient: vertical; overflow: hidden; }
.jt-str-toggle {
  color: var(--fg-tertiary);
  cursor: pointer;
  font-size: 16px;
  font-family: var(--font-sans);
  display: inline-block;
  padding: 2px 6px;
  margin-top: 2px;
  background: var(--bg);
  border-radius: 4px;
  border: 1px solid var(--border);
}
.jt-str-toggle:hover { color: var(--fg); background: var(--border); }
.jt-num { color: var(--code-num); }
.jt-bool { color: var(--code-bool); font-weight: 600; }
.jt-null { color: var(--fg-tertiary); }
.jt-summary { color: var(--fg-tertiary); font-size: 16px; }
.jt-copy {
  opacity: 0;
  cursor: pointer;
  color: var(--fg-tertiary);
  margin-left: 8px;
  flex-shrink: 0;
  transition: opacity 0.15s, color 0.15s;
  display: inline-flex;
  align-items: center;
  align-self: center;
  line-height: 0;
}
.jt-row:hover > .jt-copy { opacity: 0.6; }
.jt-copy:hover { opacity: 1 !important; color: var(--fg); }
.jt-copy svg { display: block; }

/* Scrollbar */
::-webkit-scrollbar { width: 10px; height: 10px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border-strong); border-radius: 5px; border: 2px solid transparent; background-clip: padding-box; }
::-webkit-scrollbar-thumb:hover { background: var(--fg-tertiary); border: 2px solid transparent; background-clip: padding-box; }

/* Resize handle */
#resize-handle {
  width: 4px;
  cursor: col-resize;
  background: transparent;
  flex-shrink: 0;
  transition: background 0.2s ease;
  z-index: 10;
  position: relative;
  /* Shift slightly to overlap the border visually */
  margin-left: -2px;
  margin-right: -2px;
}
#resize-handle:hover, #resize-handle.dragging { background: var(--border-strong); }
</style>
</head>
<body>
<div id="container">
  <div id="left">
    <div id="toolbar">
      <button class="nav-btn" id="btn-back-list" title="Back to log files">Logs</button>
      <span class="title" id="log-title">No log loaded</span>
      <input type="text" id="search-box" placeholder="Search... (/)">
      <div class="filter-group" id="filter-group"></div>
    </div>
    <div id="log-list"></div>
  </div>
  <div id="resize-handle"></div>
  <div id="right">
    <div id="right-toolbar">
      <span class="label" id="right-label"></span>
      <button class="action-btn" id="btn-copy" title="Copy JSON">Copy</button>
      <button class="action-btn" id="btn-expand-all" title="Expand all">Expand All</button>
      <button class="action-btn" id="btn-collapse-all" title="Collapse all">Collapse All</button>
      <button class="action-btn" id="btn-raw" title="Toggle raw text">Raw</button>
    </div>
    <div id="json-view"><span class="empty-hint">Select a log line to view details</span></div>
  </div>
</div>

<script>
const LOG_RE = /^\[([^\]]+)\]\s+(\S+)\s+(.*)/;
const ALL_TYPES = ['GENERAL','LLM_CONFIG','LLM_PAYLOAD','LLM_STREAM','UI_EVENT','RESPONSE','EXECUTION','TERMINAL'];
const DEFAULT_FILTERS = new Set(['LLM_CONFIG','LLM_PAYLOAD','LLM_STREAM']);

let logLines = [];
let selectedIdx = -1;
let activeFilters = new Set();
let searchQuery = '';
let showRaw = false;
let viewerMode = 'files';

function setViewerMode(mode) {
  viewerMode = mode;
  const isLogMode = mode === 'log';
  document.getElementById('btn-back-list').style.display = isLogMode ? '' : 'none';
  document.getElementById('search-box').style.display = isLogMode ? '' : 'none';
  document.getElementById('filter-group').style.display = isLogMode ? '' : 'none';
  for (const id of ['btn-copy', 'btn-expand-all', 'btn-collapse-all', 'btn-raw']) {
    document.getElementById(id).disabled = !isLogMode;
  }
}

document.getElementById('btn-back-list').addEventListener('click', () => {
  location.search = '';
});

async function loadLogList() {
  setViewerMode('files');
  const title = document.getElementById('log-title');
  const list = document.getElementById('log-list');
  const label = document.getElementById('right-label');
  const view = document.getElementById('json-view');
  title.textContent = 'Log files';
  label.textContent = 'Select a log file';
  view.innerHTML = '<span class="empty-hint">Choose a log file from the left list</span>';
  list.innerHTML = '<div class="log-line"><span class="msg">Loading...</span></div>';

  try {
    const resp = await fetch('/api/logs');
    if (!resp.ok) throw new Error(resp.statusText);
    const files = await resp.json();
    list.innerHTML = '';

    if (files.length === 0) {
      list.innerHTML = '<div class="log-line"><span class="msg">No log files found</span></div>';
      return;
    }

    const frag = document.createDocumentFragment();
    files.forEach((file, idx) => {
      const div = document.createElement('div');
      div.className = 'log-line';
      const mtime = new Date(file.mtime * 1000).toLocaleString();
      div.innerHTML =
        '<span class="lineno">' + (idx + 1) + '</span>' +
        '<span class="ts">' + esc(mtime) + '</span> ' +
        '<span class="msg">' + esc(file.relative_path) + '</span> ' +
        '<span class="json-inline">' + esc(formatBytes(file.size_bytes)) + '</span>';
      div.addEventListener('click', () => {
        location.search = '?log=' + encodeURIComponent(file.path);
      });
      frag.appendChild(div);
    });
    list.appendChild(frag);
  } catch (e) {
    title.textContent = 'Error: ' + e.message;
    list.innerHTML = '<div class="log-line"><span class="msg">Failed to load log files</span></div>';
  }
}

// --- Data loading ---
async function loadLog() {
  const params = new URLSearchParams(location.search);
  const logPath = params.get('log');
  if (!logPath) {
    await loadLogList();
    return;
  }
  setViewerMode('log');
  document.getElementById('log-title').textContent = logPath.split('/').slice(-2).join('/');
  try {
    const resp = await fetch('/api/log?path=' + encodeURIComponent(logPath));
    if (!resp.ok) throw new Error(resp.statusText);
    const text = await resp.text();
    parseLog(text);
    renderLogList();
    // Do not call applyFilters() here anymore since renderLogList already calculates initial visibility
  } catch (e) {
    document.getElementById('log-title').textContent = 'Error: ' + e.message;
  }
}

function parseLog(text) {
  logLines = [];
  const raw = text.split('\n');
  for (let i = 0; i < raw.length; i++) {
    const line = raw[i];
    if (!line.trim()) continue;
    const m = line.match(LOG_RE);
    if (m) {
      const rest = m[3];
      // Try to find JSON in the rest
      let textPart = rest, jsonPart = null, jsonObj = null;
      const jsonStart = rest.indexOf('{');
      if (jsonStart >= 0) {
        const candidate = rest.slice(jsonStart);
        try {
          jsonObj = JSON.parse(candidate);
          jsonPart = candidate;
          textPart = rest.slice(0, jsonStart).trimEnd();
        } catch { /* not JSON, keep as text */ }
      }
      // If no object JSON, try array
      if (!jsonObj) {
        const arrStart = rest.indexOf('[');
        if (arrStart >= 0 && arrStart !== 0) {
          const candidate = rest.slice(arrStart);
          try {
            jsonObj = JSON.parse(candidate);
            jsonPart = candidate;
            textPart = rest.slice(0, arrStart).trimEnd();
          } catch { /* not JSON */ }
        }
      }
      logLines.push({ ts: m[1], type: m[2], text: textPart, json: jsonPart, jsonObj, raw: line, lineNo: i + 1 });
    } else {
      logLines.push({ ts: '', type: '', text: line, json: null, jsonObj: null, raw: line, lineNo: i + 1 });
    }
  }
}

// --- Filter buttons ---
function buildFilters() {
  const group = document.getElementById('filter-group');
  ALL_TYPES.forEach(t => {
    const btn = document.createElement('button');
    btn.className = 'filter-btn';
    btn.textContent = t;
    btn.dataset.type = t;
    if (DEFAULT_FILTERS.has(t)) {
      activeFilters.add(t);
      btn.classList.add('active');
    }
    btn.addEventListener('click', () => toggleFilter(t, btn));
    group.appendChild(btn);
  });
}

function toggleFilter(type, btn) {
  if (activeFilters.has(type)) {
    activeFilters.delete(type);
    btn.classList.remove('active');
  } else {
    activeFilters.add(type);
    btn.classList.add('active');
  }
  applyFilters();

  if (selectedIdx >= 0) {
    const list = document.getElementById('log-list');
    const selected = list.children[selectedIdx];
    if (selected && !selected.classList.contains('hidden')) {
      const listRect = list.getBoundingClientRect();
      const rowRect = selected.getBoundingClientRect();
      const fullyVisible = rowRect.top >= listRect.top && rowRect.bottom <= listRect.bottom;
      if (!fullyVisible) {
        selected.scrollIntoView({ block: 'center' });
      }
    }
  }
}

function applyFilters() {
  if (viewerMode !== 'log') return;
  const list = document.getElementById('log-list');
  const items = list.children;
  for (let i = 0; i < items.length; i++) {
    const entry = logLines[i];
    if (!entry) continue;
    let visible = true;
    if (activeFilters.size > 0 && entry.type && !activeFilters.has(entry.type)) {
      visible = false;
    }
    if (visible && searchQuery) {
      const hay = entry.raw.toLowerCase();
      if (!hay.includes(searchQuery)) visible = false;
    }
    items[i].classList.toggle('hidden', !visible);
  }
}

// --- Render log list ---
function renderLogList() {
  const list = document.getElementById('log-list');
  list.innerHTML = '';
  const frag = document.createDocumentFragment();
  logLines.forEach((entry, idx) => {
    let visible = true;
    if (activeFilters.size > 0 && entry.type && !activeFilters.has(entry.type)) {
      visible = false;
    }
    if (visible && searchQuery) {
      const hay = entry.raw.toLowerCase();
      if (!hay.includes(searchQuery)) visible = false;
    }
    
    const div = document.createElement('div');
    div.className = 'log-line';
    if (!visible) div.classList.add('hidden');
    div.dataset.idx = idx;

    let html = '<span class="lineno">' + entry.lineNo + '</span>';
    if (entry.ts) {
      // Show only time part (trim date)
      const timePart = entry.ts.includes(' ') ? entry.ts.split(' ')[1] : entry.ts;
      html += '<span class="ts">' + esc(timePart) + '</span> ';
      html += '<span class="dtype-wrapper"><span class="dtype dtype-' + entry.type + '">' + esc(entry.type) + '</span></span> ';
      html += '<span class="msg">' + badgeify(entry.text) + '</span>';
      const summary = summarizeJson(entry);
      if (summary) {
        html += ' <span class="json-inline">' + esc(summary) + '</span>';
      }
    } else {
      html += '<span class="msg">' + esc(entry.text) + '</span>';
    }
    div.innerHTML = html;
    div.addEventListener('click', () => selectLine(idx));
    frag.appendChild(div);
  });
  list.appendChild(frag);
}

function selectLine(idx) {
  const list = document.getElementById('log-list');
  if (selectedIdx >= 0 && list.children[selectedIdx]) {
    list.children[selectedIdx].classList.remove('selected');
  }
  selectedIdx = idx;
  list.children[idx].classList.add('selected');
  renderDetail(logLines[idx]);
}

// --- JSON tree renderer ---
function renderDetail(entry) {
  const view = document.getElementById('json-view');
  const label = document.getElementById('right-label');
  showRaw = false;

  if (entry.jsonObj) {
    label.textContent = 'Line ' + entry.lineNo + ' - ' + entry.type + (entry.text ? ' ' + entry.text : '');
    view.innerHTML = '';
    view.appendChild(buildJsonTree(entry.jsonObj));
  } else {
    label.textContent = 'Line ' + entry.lineNo + ' - ' + entry.type;
    view.innerHTML = '';
    const pre = document.createElement('pre');
    pre.style.cssText = 'margin:0;padding:16px;white-space:pre-wrap;word-break:break-all;font:inherit;';
    pre.textContent = entry.raw;
    view.appendChild(pre);
  }
}

const _COLLAPSE_KEYS = new Set(['tools']);
let _jLineNo = 0;

function buildJsonTree(value) {
  _jLineNo = 0;
  const root = document.createElement('div');
  _buildNode(root, null, value, 0);
  return root;
}

function _buildNode(parent, key, value, depth) {
  const isObj = value !== null && typeof value === 'object';
  const isArr = Array.isArray(value);
  _jLineNo++;

  const row = document.createElement('div');
  row.className = 'jt-row';

  // Line number
  const ln = document.createElement('span');
  ln.className = 'jt-lineno';
  ln.textContent = _jLineNo;
  row.appendChild(ln);

  // Indent
  if (depth > 0) {
    const indent = document.createElement('span');
    indent.className = 'jt-indent';
    indent.style.width = (depth * 20) + 'px';
    row.appendChild(indent);
  }

  if (isObj) {
    const entries = isArr ? value.map((v, i) => [String(i), v]) : Object.entries(value);

    // Arrow
    const arrow = document.createElement('span');
    arrow.className = 'jt-arrow';
    arrow.textContent = entries.length > 0 ? '\u25BC' : '';
    row.appendChild(arrow);

    // Key
    if (key !== null) {
      row.appendChild(_mkSpan(String(key), 'jt-key'));
      row.appendChild(_mkSpan(': ', 'jt-colon'));
    }

    // Summary
    const summary = isArr
      ? 'Array(' + entries.length + ')'
      : '{' + entries.length + (entries.length === 1 ? ' key' : ' keys') + '}';
    row.appendChild(_mkSpan(summary, 'jt-summary'));
    row.appendChild(_mkCopy(value));
    parent.appendChild(row);

    // Children
    if (entries.length > 0) {
      const childDiv = document.createElement('div');
      childDiv.className = 'jt-children';
      entries.forEach(([k, v]) => _buildNode(childDiv, k, v, depth + 1));
      parent.appendChild(childDiv);

      // Default collapse for certain keys
      const startCollapsed = _COLLAPSE_KEYS.has(key);
      if (startCollapsed) {
        childDiv.style.display = 'none';
        arrow.textContent = '\u25B6';
        arrow.classList.add('collapsed');
      }

      arrow._jChildren = childDiv;
      arrow.onclick = () => {
        const collapsed = childDiv.style.display !== 'none';
        childDiv.style.display = collapsed ? 'none' : '';
        arrow.textContent = collapsed ? '\u25B6' : '\u25BC';
        arrow.classList.toggle('collapsed', collapsed);
      };
    }
  } else {
    // Leaf value
    const ph = document.createElement('span');
    ph.className = 'jt-arrow-ph';
    row.appendChild(ph);

    if (key !== null) {
      row.appendChild(_mkSpan(String(key), 'jt-key'));
      row.appendChild(_mkSpan(': ', 'jt-colon'));
    }

    if (value === null) {
      row.appendChild(_mkSpan('null', 'jt-null'));
    } else if (typeof value === 'string') {
      const lineCount = value.split('\n').length;
      const needsClamp = lineCount > 10;
      const wrapper = document.createElement('span');
      wrapper.style.cssText = 'min-width:0;flex:1;';
      const strSpan = _mkSpan('"' + value + '"', 'jt-str');
      if (needsClamp) strSpan.classList.add('clamped');
      wrapper.appendChild(strSpan);
      if (needsClamp) {
        const toggle = document.createElement('span');
        toggle.className = 'jt-str-toggle';
        toggle.textContent = 'Show all (' + lineCount + ' lines)';
        toggle.onclick = (e) => {
          e.stopPropagation();
          const isClamped = strSpan.classList.contains('clamped');
          strSpan.classList.toggle('clamped', !isClamped);
          toggle.textContent = isClamped ? 'Show less' : 'Show all (' + lineCount + ' lines)';
        };
        wrapper.appendChild(toggle);
      }
      row.appendChild(wrapper);
    } else if (typeof value === 'number') {
      row.appendChild(_mkSpan(String(value), 'jt-num'));
    } else if (typeof value === 'boolean') {
      row.appendChild(_mkSpan(String(value), 'jt-bool'));
    }

    row.appendChild(_mkCopy(value));
    parent.appendChild(row);
  }
}

function _mkSpan(text, cls) {
  const s = document.createElement('span');
  s.className = cls;
  s.textContent = text;
  return s;
}

function _mkCopy(value) {
  const btn = document.createElement('span');
  btn.className = 'jt-copy';
  btn.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>';
  btn.title = 'Copy';
  btn.onclick = (e) => {
    e.stopPropagation();
    const text = typeof value === 'string' ? value : JSON.stringify(value, null, 2);
    navigator.clipboard.writeText(text);
  };
  return btn;
}

// --- Actions ---
document.getElementById('btn-copy').addEventListener('click', () => {
  if (selectedIdx < 0) return;
  const entry = logLines[selectedIdx];
  const text = entry.jsonObj ? JSON.stringify(entry.jsonObj, null, 2) : entry.raw;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('btn-copy');
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = 'Copy', 1500);
  });
});

document.getElementById('btn-expand-all').addEventListener('click', () => {
  document.querySelectorAll('#json-view .jt-arrow.collapsed').forEach(el => {
    el.classList.remove('collapsed');
    el.textContent = '\u25BC';
    if (el._jChildren) el._jChildren.style.display = '';
  });
});

document.getElementById('btn-collapse-all').addEventListener('click', () => {
  document.querySelectorAll('#json-view .jt-arrow:not(.collapsed)').forEach(el => {
    if (!el._jChildren) return;
    el.classList.add('collapsed');
    el.textContent = '\u25B6';
    el._jChildren.style.display = 'none';
  });
});

document.getElementById('btn-raw').addEventListener('click', () => {
  if (selectedIdx < 0) return;
  const entry = logLines[selectedIdx];
  const view = document.getElementById('json-view');
  showRaw = !showRaw;
  if (showRaw) {
    view.innerHTML = '';
    const pre = document.createElement('pre');
    pre.style.cssText = 'margin:0;padding:16px;white-space:pre-wrap;word-break:break-all;font:inherit;';
    pre.textContent = entry.raw;
    view.appendChild(pre);
  } else {
    renderDetail(entry);
  }
});

// --- Search ---
const searchBox = document.getElementById('search-box');
searchBox.addEventListener('input', () => {
  if (viewerMode !== 'log') return;
  searchQuery = searchBox.value.toLowerCase();
  applyFilters();
});
document.addEventListener('keydown', (e) => {
  if (viewerMode === 'log' && e.key === '/' && document.activeElement !== searchBox) {
    e.preventDefault();
    searchBox.focus();
  }
  if (e.key === 'Escape') {
    searchBox.value = '';
    searchQuery = '';
    searchBox.blur();
    if (viewerMode === 'log') applyFilters();
  }
  // Arrow keys for navigation
  if (viewerMode === 'log' && (e.key === 'ArrowDown' || e.key === 'ArrowUp')) {
    e.preventDefault();
    navigateLine(e.key === 'ArrowDown' ? 1 : -1);
  }
});

function navigateLine(direction) {
  if (viewerMode !== 'log') return;
  const list = document.getElementById('log-list');
  let next = selectedIdx + direction;
  // Skip hidden lines
  while (next >= 0 && next < logLines.length && list.children[next].classList.contains('hidden')) {
    next += direction;
  }
  if (next >= 0 && next < logLines.length) {
    selectLine(next);
    list.children[next].scrollIntoView({ block: 'nearest' });
  }
}

// --- Resize handle ---
const handle = document.getElementById('resize-handle');
const right = document.getElementById('right');
let dragging = false;
handle.addEventListener('mousedown', (e) => {
  dragging = true;
  handle.classList.add('dragging');
  e.preventDefault();
});
document.addEventListener('mousemove', (e) => {
  if (!dragging) return;
  const containerWidth = document.getElementById('container').offsetWidth;
  const newWidth = containerWidth - e.clientX;
  const clamped = Math.max(200, Math.min(containerWidth - 200, newWidth));
  right.style.width = clamped + 'px';
  right.style.flex = 'none';
});
document.addEventListener('mouseup', () => {
  if (dragging) {
    dragging = false;
    handle.classList.remove('dragging');
  }
});

// --- Auto-reload ---
let lastContent = '';
async function pollForUpdates() {
  const params = new URLSearchParams(location.search);
  const logPath = params.get('log');
  if (!logPath) return;
  try {
    const resp = await fetch('/api/log?path=' + encodeURIComponent(logPath));
    if (!resp.ok) return;
    const text = await resp.text();
    if (text === lastContent) return;
    lastContent = text;
    
    // Check if initial load
    const isInitial = (logLines.length === 0);
    const prevCount = logLines.length;
    parseLog(text);

    // Append only new lines to the DOM
    const list = document.getElementById('log-list');
    const frag = document.createDocumentFragment();
    for (let idx = prevCount; idx < logLines.length; idx++) {
      const entry = logLines[idx];
      let visible = true;
      if (activeFilters.size > 0 && entry.type && !activeFilters.has(entry.type)) {
        visible = false;
      }
      if (visible && searchQuery) {
        const hay = entry.raw.toLowerCase();
        if (!hay.includes(searchQuery)) visible = false;
      }

      const div = document.createElement('div');
      div.className = 'log-line';
      if (!visible) div.classList.add('hidden');
      div.dataset.idx = idx;
      let html = '<span class="lineno">' + entry.lineNo + '</span>';
      if (entry.ts) {
        const timePart = entry.ts.includes(' ') ? entry.ts.split(' ')[1] : entry.ts;
        html += '<span class="ts">' + esc(timePart) + '</span> ';
        html += '<span class="dtype-wrapper"><span class="dtype dtype-' + entry.type + '">' + esc(entry.type) + '</span></span> ';
        html += '<span class="msg">' + badgeify(entry.text) + '</span>';
        const summary = summarizeJson(entry);
        if (summary) {
          html += ' <span class="json-inline">' + esc(summary) + '</span>';
        }
      } else {
        html += '<span class="msg">' + esc(entry.text) + '</span>';
      }
      div.innerHTML = html;
      div.addEventListener('click', () => selectLine(idx));
      frag.appendChild(div);
    }
    list.appendChild(frag);
    applyFilters();

    // Re-mark the selected line (class only, don't rebuild detail)
    if (selectedIdx >= 0 && list.children[selectedIdx]) {
      list.children[selectedIdx].classList.add('selected');
    }

    // Auto-scroll to bottom if near bottom
    if (list.scrollHeight - list.scrollTop - list.clientHeight < 100) {
      list.scrollTop = list.scrollHeight;
    }
  } catch { /* ignore polling errors */ }
}
setInterval(pollForUpdates, 2000);

// --- Helpers ---
function esc(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }
function summarizeJson(entry) {
  if (!entry.jsonObj) return entry.json ? truncate(entry.json, 120) : '';
  if (entry.type === 'LLM_STREAM') return extractInteresting(entry.jsonObj);
  return truncate(entry.json, 120);
}
// Recursively pick short/meaningful leaf values from an object
function extractInteresting(obj) {
  const parts = [];
  _extract(obj, '', parts);
  return parts.length > 0 ? parts.join(' | ') : '';
}
const _SKIP_KEYS = new Set(['id','item_id','object','created','index','output_index',
  'content_index','summary_index','sequence_number','type','model','provider',
  'logprobs','obfuscation','prompt_tokens_details','completion_tokens_details',
  'cost_details','debug','prompt_tokens','is_byok','native_finish_reason']);
function _extract(val, key, parts) {
  if (val == null) return;
  if (typeof val === 'string') {
    if (!val || _SKIP_KEYS.has(key)) return;
    // Skip long blobs (base64, encrypted, system prompts)
    if (val.length > 200) { parts.push(key + ': ' + truncate(val, 40)); return; }
    parts.push(key ? key + ': ' + val : val);
    return;
  }
  if (typeof val === 'number') {
    if (_SKIP_KEYS.has(key)) return;
    parts.push(key + ': ' + val);
    return;
  }
  if (typeof val === 'boolean') {
    if (_SKIP_KEYS.has(key)) return;
    parts.push(key + ': ' + val);
    return;
  }
  if (Array.isArray(val)) {
    for (const item of val) _extract(item, key, parts);
    return;
  }
  if (typeof val === 'object') {
    if (_SKIP_KEYS.has(key)) return;
    for (const [k, v] of Object.entries(val)) _extract(v, k, parts);
  }
}
function badgeify(s) {
  return esc(s).replace(/\[([\w.]+)\]/g, '<span class="badge">$1</span>');
}
function truncate(s, n) { return s.length <= n ? s : s.slice(0, n) + '...'; }
function formatBytes(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

// --- Init ---
buildFilters();
loadLog();
</script>
</body>
</html>
